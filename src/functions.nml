/* Begin Functions */

/* Building Classes
*
*	Class 0
*	Buildings in class: House, Market, Warehouse, Fountain, Statue
*
*	Class 1
*	Parks cannot be within 2 tiles of another park
*
*	Class 2
*	Skyscrapers/office towers can only build within 5 tiles of another skyscraper/office towers
*	Buildings in class: skyscrapers, office towers
*
*	Class 3
*	Temple
*
*	Class 4
*	Old houses (must be within 2 tiles of another old house, to prevent sparse town growth with house limit)
*
*	Class 5
*	Skyscrapers
*
*/

// Small Flats cannot build within 1 tile of a modern office building unless no passenger service is provided to the tile
switch(FEAT_HOUSES, SELF, ClassTwoWithinOneTile,
	// Shops and Offices
	nearby_tile_house_class(0,1) == 258 ||
	nearby_tile_house_class(0,-1) == 258 ||
	nearby_tile_house_class(1,0) == 258 ||
	nearby_tile_house_class(1,1) == 258 ||
	nearby_tile_house_class(1,-1) == 258 ||
	nearby_tile_house_class(-1,0) == 258 ||
	nearby_tile_house_class(-1,1) == 258 ||
	nearby_tile_house_class(-1,-1) == 258 ||
	// Skyscrapers
	nearby_tile_house_class(0,1) == 261 ||
	nearby_tile_house_class(0,-1) == 261 ||
	nearby_tile_house_class(1,0) == 261 ||
	nearby_tile_house_class(1,1) == 261 ||
	nearby_tile_house_class(1,-1) == 261 ||
	nearby_tile_house_class(-1,0) == 261 ||
	nearby_tile_house_class(-1,1) == 261 ||
	nearby_tile_house_class(-1,-1) == 261
		){return;}

// Function looking for no Passenger service, but there is a Class Two Building nearby
switch(FEAT_HOUSES, SELF, NoPassBesideModernOffice,
	ClassTwoWithinOneTile() &&
	FuncNoServicePASS()
		){return;}

// Small Apartments Check - There must be Passenger Service, but if there is not, and there is a Class Two Building nearby, allow building
switch(FEAT_HOUSES, SELF, SmallApartmentsCheck,
	NoPassBesideModernOffice() ||
	FuncServicePASS()
		){return;}

// Check for road (and stations) in adjacent tiles functions
//switch (FEAT_HOUSES, SELF, HasRoadAdjacentNW, nearby_tile_class( 0,-1) == TILE_CLASS_ROAD || nearby_tile_class( 0,-1) == TILE_CLASS_STATION) {return;}
switch (FEAT_HOUSES, SELF, HasRoadAdjacentSE, nearby_tile_class( 0, 1) == TILE_CLASS_ROAD || nearby_tile_class( 0, 1) == TILE_CLASS_STATION) {return;}
switch (FEAT_HOUSES, SELF, HasRoadAdjacentSW, nearby_tile_class( 1, 0) == TILE_CLASS_ROAD || nearby_tile_class( 1, 0) == TILE_CLASS_STATION) {return;}

switch (FEAT_HOUSES, SELF, HasRoadAdjacentSE2x2, nearby_tile_class(0,2) == TILE_CLASS_ROAD || nearby_tile_class(0,2) == TILE_CLASS_STATION) {return;}

switch (FEAT_HOUSES, SELF, HasRoadAdjacentNWSW, 
	nearby_tile_class( 0,-1) == TILE_CLASS_ROAD || 
	nearby_tile_class( 0,-1) == TILE_CLASS_STATION || 
	nearby_tile_class( 1, 0) == TILE_CLASS_ROAD || 
	nearby_tile_class( 1, 0) == TILE_CLASS_STATION
	) {return;}

/* House is Unique */
switch (FEAT_HOUSES, SELF, IsUniqueHouse, same_house_count_town == 0) {return;}

/* Can only appear when town is being generated */
switch (FEAT_HOUSES, SELF, OnGenerationOnly, generating_town == 1) {return;}

/* Probabilities */
switch (FEAT_HOUSES, SELF, RandomBitsFour, random_bits % 4 == 0) {return;}

/* Radius Checks */
/* There is a building of the same class within a radius of 2, or there is no building of that class */
switch (FEAT_HOUSES, SELF, WithinTwoOfSameClass, nearest_house_matching_criterion(2, SEARCH_HOUSE_BY_CLASS) >= 1 || same_class_count_town == 0 ) {return;}
switch (FEAT_HOUSES, SELF, ThirtyTileGap, nearest_house_matching_criterion(30, SEARCH_HOUSE_BY_TYPE) == 0 ) {return;}

//switch (FEAT_HOUSES, SELF, IsUniqueInRadius, radius, nearest_house_matching_criterion(radius, SEARCH_HOUSE_BY_TYPE) == 0) {return;}

//switch (FEAT_HOUSES, SELF, HasSameClassNearby, radius, nearest_house_matching_criterion(radius, SEARCH_HOUSE_BY_CLASS) ) {0: return 0; return 1;}

//switch (FEAT_HOUSES, SELF, IsFirstHouseOfClass, same_class_count_town == 0) {return;}

/* End Functions */
