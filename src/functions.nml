/* Begin Functions */

/* Building Classes
*
*	Class 0
*	Buildings in class: House, Market, Warehouse, Fountain, Statue
*
*	Class 1
*	Parks cannot be within 2 tiles of another park
*
*	Class 2
*	Skyscrapers/office towers can only build within 5 tiles of another skyscraper/office towers
*	Buildings in class: skyscrapers, office towers
*
*	Class 3
*	Temple
*
*	Class 4
*	Old houses (must be within 2 tiles of another old house, to prevent sparse town growth with house limit)
*
*	Class 5
*	Skyscrapers
*
*/

/* Functions checking for service of cargoes */

// Passenger Service
switch(FEAT_HOUSES, SELF, FuncServicePASS, 	(cargo_accepted_nearby_last_month(PASS) == 1 || cargo_accepted_nearby_this_month(PASS) == 1)) {return;}
switch(FEAT_HOUSES, SELF, FuncNoServicePASS, (cargo_accepted_nearby_last_month(PASS) == 0 || cargo_accepted_nearby_this_month(PASS) == 0)) {return;}
// Petroleum Fuels Service - for Petrol Stations
switch(FEAT_HOUSES, SELF, FuncServicePETR, (cargo_accepted_nearby_last_month(PETR) == 1 || cargo_accepted_nearby_this_month(PETR) == 1)) {return;}

/* Production loop, shared by all houses. Individual production rates stored in temporary registers in the function below.*/


switch (FEAT_HOUSES, SELF, switch_alt_production, getbits(extra_callback_info1, 0, 8)) {
	0: (PASS * 256) + (abs(extra_callback_info2 % 8) == 0) * LOAD_TEMP(1);
	1: (MAIL * 256) + (abs(extra_callback_info2 % 8) == 0) * LOAD_TEMP(2);
	return CB_RESULT_HOUSE_NO_MORE_PRODUCTION;
}

/* Production levels for passengers and mail, are passed as arguments to this function for use in the production loop. */
switch (FEAT_HOUSES, SELF, func_produce, pass, mail, [STORE_TEMP(pass, 1), STORE_TEMP(mail, 2)] ) {switch_alt_production;}


/* Functions to determine whether Class 2 Buildings (Shops and Offices) */

// Function to add the the numbers of residential building, with a population factor based on size
switch(FEAT_HOUSES, SELF, FuncPopulationAdder,
	
	// Houses
	(other_house_count_town(26)*2)+ 	// Naganuma House
	(other_house_count_town(65)*2)+ 	// Nishikawa House

	// Takamaro Houses
	(other_house_count_town(52)*3)+ 	// Takamaro_01
	(other_house_count_town(53)*3)+ 	// Takamaro_02
	(other_house_count_town(54)*3)+ 	// Takamaro_03
	(other_house_count_town(55)*3)+ 	// Takamaro_04

	// Town Houses
	(other_house_count_town(05)*3)+ 	// Townhouses_02
	(other_house_count_town(06)*3)+ 	// Townhouses_01
	
	// Apartments		
	(other_house_count_town(27)*10)+ 	// Apartments_01
	(other_house_count_town(30)*10)+ 	// Apartments_02
	(other_house_count_town(56)*10)+ 	// Apartments_04	

	// Small Apartments
	(other_house_count_town(02)*4)+ 	// Small Apartments 01
	(other_house_count_town(44)*4)+ 	// Small Apartments 02
	(other_house_count_town(45)*4) 		// Small Apartments 03
	) {return;}

// Houses and Town Houses cannot build within 2 tiles of a modern office building
switch(FEAT_HOUSES, SELF, HouseOfficeGap,
	nearby_tile_house_class(0,1) != 258 ||
	nearby_tile_house_class(0,-1) != 258 ||
	nearby_tile_house_class(1,0) != 258 ||
	nearby_tile_house_class(1,1) != 258 ||
	nearby_tile_house_class(1,-1) != 258 ||
	nearby_tile_house_class(-1,0) != 258 ||
	nearby_tile_house_class(-1,1) != 258 ||
	nearby_tile_house_class(-1,-1) != 258 ||
	nearby_tile_house_class(-2,-2) != 258 ||
	nearby_tile_house_class(-2,-1) != 258 ||
	nearby_tile_house_class(-2,0) != 258 ||
	nearby_tile_house_class(-2,1) != 258 ||
	nearby_tile_house_class(-2,2) != 258 ||
	nearby_tile_house_class(-1,-2) != 258 ||
	nearby_tile_house_class(-1,2) != 258 ||
	nearby_tile_house_class(0,-2) != 258 ||
	nearby_tile_house_class(0,-2) != 258 ||
	nearby_tile_house_class(1,-2) != 258 ||
	nearby_tile_house_class(1,-2) != 258 ||
	nearby_tile_house_class(2,-2) != 258 ||
	nearby_tile_house_class(2,-1) != 258 ||
	nearby_tile_house_class(2,0) != 258 ||
	nearby_tile_house_class(2,1) != 258 ||
	nearby_tile_house_class(2,2) != 258
		){return;}

// Small Flats cannot build within 1 tile of a modern office building unless no passenger service is provided to the tile
switch(FEAT_HOUSES, SELF, ClassTwoWithinOneTile,
	nearby_tile_house_class(0,1) == 258 ||
	nearby_tile_house_class(0,-1) == 258 ||
	nearby_tile_house_class(1,0) == 258 ||
	nearby_tile_house_class(1,1) == 258 ||
	nearby_tile_house_class(1,-1) == 258 ||
	nearby_tile_house_class(-1,0) == 258 ||
	nearby_tile_house_class(-1,1) == 258 ||
	nearby_tile_house_class(-1,-1) == 258
		){return;}

// Function looking for no Passenger service, but there is a Class Two Building nearby
switch(FEAT_HOUSES, SELF, NoPassBesideModernOffice,
	ClassTwoWithinOneTile() &&
	FuncNoServicePASS()
		){return;}

// Small Apartments Check - There must be Passenger Service, but if there is not, and there is a Class Two Building nearby, allow building
switch(FEAT_HOUSES, SELF, SmallApartmentsCheck,
	NoPassBesideModernOffice() ||
	FuncServicePASS()
		){return;}

// Check for road (and stations) in adjacent tiles functions
switch (FEAT_HOUSES, SELF, HasRoadAdjacentNW, nearby_tile_class(0,-1) == TILE_CLASS_ROAD || nearby_tile_class(0,-1) == TILE_CLASS_STATION) {return;}
switch (FEAT_HOUSES, SELF, HasRoadAdjacentSE, nearby_tile_class(0,1) == TILE_CLASS_ROAD || nearby_tile_class(0,1) == TILE_CLASS_STATION) {return;}
switch (FEAT_HOUSES, SELF, HasRoadAdjacentSW, nearby_tile_class(1,0) == TILE_CLASS_ROAD || nearby_tile_class(1,0) == TILE_CLASS_STATION) {return;}

switch (FEAT_HOUSES, SELF, HasRoadAdjacentSE2x2, nearby_tile_class(0,2) == TILE_CLASS_ROAD || nearby_tile_class(0,2) == TILE_CLASS_STATION) {return;}

switch (FEAT_HOUSES, SELF, HasRoadAdjacentNWSW, 
	nearby_tile_class( 0,-1) == TILE_CLASS_ROAD || 
	nearby_tile_class( 0,-1) == TILE_CLASS_STATION || 
	nearby_tile_class( 1, 0) == TILE_CLASS_ROAD || 
	nearby_tile_class( 1, 0) == TILE_CLASS_STATION
	) {return;}


/* Note: Per NML specs, returns 256+X (X = 0..255) if the house has been defined by this NewGRF with building_class X */

switch (FEAT_HOUSES, SELF, IsTileHouseClass, x, y, class_num, nearby_tile_house_class(x,y) == 256 + class_num) {return;}

switch (FEAT_HOUSES, SELF, IsAdjacentToHouseClass, class_num,
	// One square radius
	IsTileHouseClass(-1, 0, class_num) ||
	IsTileHouseClass(-1,-1, class_num) ||
	IsTileHouseClass(-1, 1, class_num) ||
	IsTileHouseClass( 0,-1, class_num) ||
	IsTileHouseClass( 0, 1, class_num) ||
	IsTileHouseClass( 1, 0, class_num) ||
	IsTileHouseClass( 1,-1, class_num) ||
	IsTileHouseClass( 1, 1, class_num) ||
	// Two square radius
	IsTileHouseClass(-2,-2, class_num) ||
	IsTileHouseClass(-2,-1, class_num) ||
	IsTileHouseClass(-2, 0, class_num) ||
	IsTileHouseClass(-2, 1, class_num) ||
	IsTileHouseClass(-2, 2, class_num) ||
	IsTileHouseClass(-1,-2, class_num) ||
	IsTileHouseClass(-1, 2, class_num) ||
	IsTileHouseClass( 0,-2, class_num) ||
	IsTileHouseClass( 0, 2, class_num) ||
	IsTileHouseClass( 1,-2, class_num) ||
	IsTileHouseClass( 1, 2, class_num) ||
	IsTileHouseClass( 2,-2, class_num) ||
	IsTileHouseClass( 2,-1, class_num) ||
	IsTileHouseClass( 2, 0, class_num) ||
	IsTileHouseClass( 2, 1, class_num) ||
	IsTileHouseClass( 2, 2, class_num) ||
	// Three square radius
	IsTileHouseClass(-3,-3, class_num) ||
	IsTileHouseClass(-3,-2, class_num) ||
	IsTileHouseClass(-3,-1, class_num) ||
	IsTileHouseClass(-3, 0, class_num) ||
	IsTileHouseClass(-3, 1, class_num) ||
	IsTileHouseClass(-3, 2, class_num) ||
	IsTileHouseClass(-3, 3, class_num) ||
	IsTileHouseClass(-1,-3, class_num) ||
	IsTileHouseClass(-1, 3, class_num) ||
	IsTileHouseClass( 0,-3, class_num) ||
	IsTileHouseClass( 0, 3, class_num) ||
	IsTileHouseClass( 1,-3, class_num) ||
	IsTileHouseClass( 1, 3, class_num) ||
	IsTileHouseClass( 2,-3, class_num) ||
	IsTileHouseClass( 2, 3, class_num) ||
	IsTileHouseClass( 3,-3, class_num) ||
	IsTileHouseClass( 3,-2, class_num) ||
	IsTileHouseClass( 3,-1, class_num) ||
	IsTileHouseClass( 3, 0, class_num) ||
	IsTileHouseClass( 3, 1, class_num) ||
	IsTileHouseClass( 3, 2, class_num) ||
	IsTileHouseClass( 3, 3, class_num) ||
	// Four square radius - adjustments to take into consideration that Temple is 2x2
	IsTileHouseClass(-4,-4, class_num) ||
	IsTileHouseClass(-4,-3, class_num) ||
	IsTileHouseClass(-4,-2, class_num) ||
	IsTileHouseClass(-4,-1, class_num) ||
	IsTileHouseClass(-4, 0, class_num) ||
	IsTileHouseClass(-4, 1, class_num) ||
	IsTileHouseClass(-4, 2, class_num) ||
	IsTileHouseClass(-4, 3, class_num) ||
	IsTileHouseClass(-4, 4, class_num) ||
	IsTileHouseClass(-3,-4, class_num) ||
	IsTileHouseClass(-2,-4, class_num) ||
	IsTileHouseClass(-1,-4, class_num) ||
	IsTileHouseClass( 0,-4, class_num) ||
	IsTileHouseClass( 1,-4, class_num) ||
	IsTileHouseClass( 2,-4, class_num) ||
	IsTileHouseClass( 3,-4, class_num) ||
	IsTileHouseClass( 4,-4, class_num)
	){return;}


/* Function for Buildings that cannot build near Temple (Building Class 3) */ 
switch (FEAT_HOUSES, SELF, BanFromHistDistrict, IsAdjacentToHouseClass(3) == 0 
	) {return;}

/* Function for Buildings that can build near the Temple (Building Class 3) to create a Historical District*/ 
switch (FEAT_HOUSES, SELF, AllowInHistDistrict, IsAdjacentToHouseClass(3) != 0 
	) {return;}

/* Must be a city */
switch (FEAT_HOUSES, PARENT, IsCity, is_city == 1) {return;}

/* Population must be over a certain level */
switch (FEAT_HOUSES, PARENT, PopOver30k, population > 30000) {return;}

/* House is Unique */
switch (FEAT_HOUSES, SELF, IsUniqueHouse, same_house_count_town == 0) {return;}

/* Can only appear when town is being generated */
switch (FEAT_HOUSES, SELF, OnGenerationOnly, generating_town == 1) {return;}

/* Probabilities */
switch (FEAT_HOUSES, SELF, RandomBitsFour, random_bits % 4 == 0) {return;}

/* Radius Checks */
/* There is a building of the same class within a radius of 2, or there is no building of that class */
switch (FEAT_HOUSES, SELF, WithinTwoOfSameClass, nearest_house_matching_criterion(2, SEARCH_HOUSE_BY_CLASS) >= 1 || same_class_count_town == 0 ) {return;}
switch (FEAT_HOUSES, SELF, ThirtyTileGap, nearest_house_matching_criterion(30, SEARCH_HOUSE_BY_TYPE) == 0 ) {return;}

/* Modern Office Population Check */
switch (FEAT_HOUSES, SELF, ModernOfficePopCheck, (FuncPopulationAdder() > ( (other_class_count_town(3) * 30) + ((1 + same_class_count_town) * 60) ) ) ) {return;}

/* Note: Check population is inaccurate when generating towns. This will only work properly when growing towns in-game. */
/*
switch (FEAT_HOUSES, PARENT, HasPopulation, required, population >= required) {return;}

switch (FEAT_HOUSES, SELF, IsUniqueInRadius, radius, nearest_house_matching_criterion(radius, SEARCH_HOUSE_BY_TYPE) == 0) {return;}

switch (FEAT_HOUSES, SELF, HasSameClassNearby, radius, nearest_house_matching_criterion(radius, SEARCH_HOUSE_BY_CLASS) ) {0: return 0; return 1;}

switch (FEAT_HOUSES, SELF, IsFirstHouseOfClass, same_class_count_town == 0) {return;}
*/

/* End Functions */
